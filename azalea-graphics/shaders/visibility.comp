#version 450

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PC {
    mat4 viewProj;
    vec4 gridOrigin_ws;
    int  radius;
    int  height;
} pc;

layout(set=0, binding=0, std430) writeonly buffer Visibility { uint visible[]; };
layout(set=1, binding=0) uniform sampler2D hizPyramid;

const int   CHUNK_SIZE = 16;
const float EPS        = 1e-6;

bool projectToScreen(vec3 worldPos, out vec2 uv, out float depth)
{
    vec4 clip = pc.viewProj * vec4(worldPos, 1.0);
    if (clip.w <= 0.0) {
        uv = vec2(0.0);
        depth = 1.0;
        return false;
    }
    vec3 ndc = clip.xyz / clip.w;
    uv    = ndc.xy * 0.5 + 0.5;
    depth = ndc.z;
    return true;
}

int linearIndex(int dx, int dy, int dz, int side)
{
    int x = dx + pc.radius;
    int z = dz + pc.radius;
    return (dy * side * side) + (z * side) + x;
}

bool aabbOutsideFrustum(vec3 corners[8], mat4 viewProj)
{
    for (int plane = 0; plane < 6; ++plane) {
        bool allOutside = true;
        for (int i = 0; i < 8; ++i) {
            vec4 clip = viewProj * vec4(corners[i], 1.0);
            if (plane == 0 && clip.x >= -clip.w) allOutside = false; // left
            if (plane == 1 && clip.x <=  clip.w) allOutside = false; // right
            if (plane == 2 && clip.y >= -clip.w) allOutside = false; // bottom
            if (plane == 3 && clip.y <=  clip.w) allOutside = false; // top
            if (plane == 4 && clip.z >=  0.0)    allOutside = false; // near
            if (plane == 5 && clip.z <=  clip.w) allOutside = false; // far
        }
        if (allOutside)
            return true;
    }
    return false;
}

float sampleHizMinRect(ivec2 minPix, ivec2 maxPix, int level)
{
    ivec2 a = min(minPix, maxPix);
    ivec2 b = max(minPix, maxPix);
    ivec2 c = (a + b) / 2;

    float d0 = texelFetch(hizPyramid, a, level).r;
    float d1 = texelFetch(hizPyramid, ivec2(b.x, a.y), level).r;
    float d2 = texelFetch(hizPyramid, ivec2(a.x, b.y), level).r;
    float d3 = texelFetch(hizPyramid, b, level).r;
    float d4 = texelFetch(hizPyramid, c, level).r;

    return max(max(max(d0, d1), max(d2, d3)), d4);
}

void main()
{
    int side = pc.radius * 2 + 1;

    ivec3 gid = ivec3(gl_GlobalInvocationID.xyz);
    if (gid.y < 0 || gid.y >= pc.height || gid.x < 0 || gid.x >= side || gid.z < 0 || gid.z >= side) {
        return;
    }

    int dx = gid.x - pc.radius;
    int dy = gid.y;
    int dz = gid.z - pc.radius;

    int index = linearIndex(dx, dy, dz, side);

    vec3 base = pc.gridOrigin_ws.xyz + vec3(dx, dy, dz) * float(CHUNK_SIZE);
    vec3 bmin = base;
    vec3 bmax = base + vec3(float(CHUNK_SIZE));

    vec3 corners[8] = vec3[8](
        vec3(bmin.x, bmin.y, bmin.z),
        vec3(bmax.x, bmin.y, bmin.z),
        vec3(bmin.x, bmax.y, bmin.z),
        vec3(bmax.x, bmax.y, bmin.z),
        vec3(bmin.x, bmin.y, bmax.z),
        vec3(bmax.x, bmin.y, bmax.z),
        vec3(bmin.x, bmax.y, bmax.z),
        vec3(bmax.x, bmax.y, bmax.z)
    );

    // Step 1: Frustum cull
    if (aabbOutsideFrustum(corners, pc.viewProj)) {
        visible[index] = 0u;
        return;
    }

    // Step 2: Project to screen space
    vec2 minUV = vec2( 1.0);
    vec2 maxUV = vec2( 0.0);
    float nearDepth = 1.0;
    bool anyValid = false;

    for (int i = 0; i < 8; ++i) {
        vec2 uv;
        float d;
        bool ok = projectToScreen(corners[i], uv, d);
        if (ok) {
            anyValid = true;
            minUV = min(minUV, uv);
            maxUV = max(maxUV, uv);
            nearDepth = min(nearDepth, d);
        }
    }

    if (!anyValid) {
        visible[index] = 1u; // skip occlusion if fully behind camera
        return;
    }

    minUV = clamp(minUV, 0.0, 1.0);
    maxUV = clamp(maxUV, 0.0, 1.0);

    vec2 extent = maxUV - minUV;
    if (extent.x <= 0.0 || extent.y <= 0.0) {
        visible[index] = 1u;
        return;
    }

    int levels = textureQueryLevels(hizPyramid);
    bool occluded = false;

    for (int level = levels - 1; level >= 0; --level) {
        ivec2 texSize = textureSize(hizPyramid, level);

        vec2 minPixF = minUV * vec2(texSize);
        vec2 maxPixF = maxUV * vec2(texSize);

        ivec2 minPix = ivec2(floor(minPixF));
        ivec2 maxPix = ivec2(max(ivec2(0), ivec2(ceil(maxPixF) - 1)));

        minPix = clamp(minPix, ivec2(0), texSize - 1);
        maxPix = clamp(maxPix, ivec2(0), texSize - 1);

        float hizMin = sampleHizMinRect(minPix, maxPix, level);

        if (hizMin + EPS < nearDepth) {
            occluded = true;
            break;
        }
    }

    visible[index] = occluded ? 0u : 1u;
}
