#version 450

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PC {
    mat4 viewProj;
    vec4 gridOrigin_ws;
    int  radius;
    int  height;
} pc;

layout(set=0, binding=0, std430) writeonly buffer Visibility { uint visible[]; };
layout(set=1, binding=0) uniform sampler2D hizPyramid;

const int   CHUNK_SIZE = 16;
const float EPS        = 1e-6;

bool projectToScreen(vec3 worldPos, out vec2 uv, out float depth)
{
    vec4 clip = pc.viewProj * vec4(worldPos, 1.0);
    if (clip.w <= 0.0) {
        uv = vec2(0.0);
        depth = 1.0;
        return false;
    }
    vec3 ndc = clip.xyz / clip.w;
    uv    = ndc.xy * 0.5 + 0.5;
    depth = ndc.z;
    return true;
}

int linearIndex(int dx, int dy, int dz, int side)
{
    int x = dx + pc.radius;
    int z = dz + pc.radius;
    return (dy * side * side) + (z * side) + x;
}

bool aabbOutsideFrustum(vec3 corners[8], mat4 viewProj)
{
    for (int plane = 0; plane < 6; ++plane) {
        bool allOutside = true;
        for (int i = 0; i < 8; ++i) {
            vec4 clip = viewProj * vec4(corners[i], 1.0);
            if (plane == 0 && clip.x >= -clip.w) allOutside = false; // left
            if (plane == 1 && clip.x <=  clip.w) allOutside = false; // right
            if (plane == 2 && clip.y >= -clip.w) allOutside = false; // bottom
            if (plane == 3 && clip.y <=  clip.w) allOutside = false; // top
            if (plane == 4 && clip.z >=  0.0)    allOutside = false; // near
            if (plane == 5 && clip.z <=  clip.w) allOutside = false; // far
        }
        if (allOutside)
            return true;
    }
    return false;
}

float sampleHizMinRect(ivec2 minPix, ivec2 maxPix, int level)
{
    ivec2 a = min(minPix, maxPix);
    ivec2 b = max(minPix, maxPix);
    ivec2 c = (a + b) / 2;

    float d0 = texelFetch(hizPyramid, a, level).r;
    float d1 = texelFetch(hizPyramid, ivec2(b.x, a.y), level).r;
    float d2 = texelFetch(hizPyramid, ivec2(a.x, b.y), level).r;
    float d3 = texelFetch(hizPyramid, b, level).r;
    float d4 = texelFetch(hizPyramid, c, level).r;

    return max(max(max(d0, d1), max(d2, d3)), d4);
}

void main()
{
    int side = pc.radius * 2 + 1;

    ivec3 gid = ivec3(gl_GlobalInvocationID.xyz);
    if (gid.y < 0 || gid.y >= pc.height || gid.x < 0 || gid.x >= side || gid.z < 0 || gid.z >= side) {
        return;
    }

    int dx = gid.x - pc.radius;
    int dy = gid.y;
    int dz = gid.z - pc.radius;

    int index = linearIndex(dx, dy, dz, side);

    vec3 base = pc.gridOrigin_ws.xyz + vec3(dx, dy, dz) * float(CHUNK_SIZE);
    vec3 bmin = base;
    vec3 bmax = base + vec3(float(CHUNK_SIZE));

    vec3 corners[8] = vec3[8](
        vec3(bmin.x, bmin.y, bmin.z),
        vec3(bmax.x, bmin.y, bmin.z),
        vec3(bmin.x, bmax.y, bmin.z),
        vec3(bmax.x, bmax.y, bmin.z),
        vec3(bmin.x, bmin.y, bmax.z),
        vec3(bmax.x, bmin.y, bmax.z),
        vec3(bmin.x, bmax.y, bmax.z),
        vec3(bmax.x, bmax.y, bmax.z)
    );

    if (aabbOutsideFrustum(corners, pc.viewProj)) {
        visible[index] = 0u;
        return;
    }

    vec2 min_xy = vec2( 1.0);
    vec2 max_xy = vec2( 0.0);
    float nearDepth = 1.0;
    bool anyValid = false;

    for (int i = 0; i < 8; ++i) {
        vec2 uv;
        float d;
        bool ok = projectToScreen(corners[i], uv, d);
        if (ok) {
            anyValid = true;
            max_xy = min(max_xy, uv);
            max_xy = max(max_xy, uv);
            nearDepth = min(nearDepth, d);
        }
    }

    if (!anyValid) {
        visible[index] = 1u;
        return;
    }

    min_xy = clamp(min_xy, 0.0, 1.0);
    max_xy = clamp(max_xy, 0.0, 1.0);

    vec2 extent = max_xy - min_xy;
    if (extent.x <= 0.0 || extent.y <= 0.0) {
        visible[index] = 1u;
        return;
    }

    ivec2 texSize = textureSize(hizPyramid, 0);
    vec2 texelSize = extent * vec2(texSize);
    float mip = floor(log2(max(texelSize.x, texelSize.y)));

    vec4 box = vec4(min_xy, max_xy);

    float sample1 = textureLod(hizPyramid, box.xy, mip).r;
    float sample2 = textureLod(hizPyramid, box.zy, mip).r;
    float sample3 = textureLod(hizPyramid, box.xw, mip).r;
    float sample4 = textureLod(hizPyramid, box.zw, mip).r;

    float max_z = max(max(max(sample1, sample2), sample3), sample4);

    visible[index] = nearDepth <= (max_z + EPS) ? 0u : 1u;
}
